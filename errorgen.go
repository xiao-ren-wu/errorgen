package errorgen

import (
	"errors"
	"fmt"
	"github.com/dave/jennifer/jen"
)

func GenFile(errMap map[int32]map[string]string, pkgName string, downloadPath string, withStack bool) error {
	gf, err := genFile(errMap, pkgName, withStack)
	if err != nil {
		return err
	}
	return gf.Save(downloadPath)
}

func genFile(errMap map[int32]map[string]string, pkgName string, withStack bool) (*jen.File, error) {
	file := jen.NewFile(pkgName)
	file.HeaderComment("// Code generated by errorgen. DO NOT EDIT.")
	file.Type().Id("BizError").Struct(
		jen.Id("Cause").Id("error"),
		jen.Id("Code").Id("ErrorCode"),
		jen.Id("Message").String(),
	)

	file.Func().Params(jen.Id("e").Id("BizError")).Id("Error").Params().String().Block(
		jen.If(jen.Id("e").Dot("Cause").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Sprintf").Call(jen.Lit("%s:%v"), jen.Id("e").Dot("Message"), jen.Id("e").Dot("Cause"))),
		),
		jen.Return(jen.Id("e").Dot("Message")),
	)

	file.Type().Id("ErrorCode").Int32()

	var errorConsts []jen.Code
	var errorCases []jen.Code
	for code, errDesp := range errMap {
		if len(errDesp) != 1 {
			return nil, errors.New("invalid config")
		}
		for errName, errMsg := range errDesp {
			errConstItem := jen.Id(errName).Op("=").Id("ErrorCode").Parens(jen.Lit(code))
			errorConsts = append(errorConsts, errConstItem)
			errCaseItem := jen.Case(jen.Id(errName)).Block(jen.Return(jen.Lit(errMsg)))
			errorCases = append(errorCases, errCaseItem)
		}
	}
	errorCases = append(errorCases, jen.Default().Block(jen.Return(jen.Lit("未知错误"))))

	file.Const().Defs(errorConsts...)

	file.Func().
		Params(jen.Id("e").Id("ErrorCode")).
		Id("Message").Params().
		String().
		Block(
			jen.Switch(jen.Id("e")).Block(errorCases...),
		)
	retCode := jen.Return(jen.Id("bizErr"))
	if withStack {
		retCode = jen.Return(jen.Qual("github.com/pkg/errors", "WithStack").Call(jen.Id("bizErr")))
	}
	for _, errDesp := range errMap {
		for errName := range errDesp {
			file.Func().Id(fmt.Sprintf("New%s", errName)).Params(jen.Id("ops").Op(" ...").Id("Option")).Id("error").Block(
				jen.Var().Id("bizErr").Op("=").Op("&").Id("BizError").Values(
					jen.Dict{
						jen.Id("Code"):    jen.Id(errName),
						jen.Id("Message"): jen.Id(errName).Dot("Message").Call(),
					},
				),
				jen.For(jen.List(jen.Id("_"), jen.Id("op")).Op(":=").Range().Id("ops")).Block(
					jen.Id("op").Call(jen.Id("bizErr")),
				),
				retCode,
			)
		}
		file.Line()
	}

	file.Type().Id("Option").Func().Params(jen.Id("*BizError"))

	file.Func().Id("Msg").
		Params(jen.Id("ErrorMessage").String(), jen.Id("args").Op("...").Interface()).Id("Option").
		Block(
			jen.Return(jen.Func().Params(jen.Id("bizErr").Op("*").Id("BizError")).
				Block(
					jen.Id("bizErr").Dot("Message").Op("=").Qual("fmt", "Sprintf").Call(jen.Id("ErrorMessage"), jen.Id("args").Op("...")),
				)),
		)
	file.Line()
	file.Func().Id("Cause").Params(jen.Id("err").Error()).Id("Option").
		Block(
			jen.Return(jen.Func().Params(jen.Id("bizError").Op("*").Id("BizError")).Block(
				jen.Id("bizError").Dot("Cause").Op("=").Id("err"),
			)),
		)

	return file, nil
}
